
---
format:
  html: {toc: true, toc-depth: 4, theme: cosmo, output-file: index.html}
code-block-background: true
title: Intro to Probability and Statistics

---
<style></style><style>.printedClojure .sourceCode {
  background-color: transparent;
  border-style: none;
}
</style><style>.clay-limit-image-width .clay-image {max-width: 100%}
.clay-side-by-side .sourceCode {margin: 0}
.clay-side-by-side {margin: 1em 0}
</style>
<script src="index_files/md-default0.js" type="text/javascript"></script><script src="index_files/md-default1.js" type="text/javascript"></script>
This tutorial assumes some familiarity with Clojure and with high-school maths (algebra, probability, statistics, _etc_.).

We use Clojure and fastmath library in this intro.


# Probability

We use probability to model _random_ experiments or observations. The outcome of a _random_ experiment or observation is determined by chance and we can not predict that outcome with absolute certainty, even in principle. Examples of _random_ experiments or observations include tossing a coin, eagle sightings, tomorrow's weather, the next president of USA, _etc_.


## Probability Model

A _random_ experiment yields outcome. An event is a member of possible outcomes from an experiment. We use probability model to tell us about probability of events.

One good way to think about probability model is a ticket-in-a-box model or "box-model", for short. This box-model replaces an observation by a box full of tickets. Each ticket has an outcome written on it. The outcome or the event written could be "head" or "tail" from tossing a coin, number of eagles seen -- it depends on what we're trying to model. All possible events are written at least once among the tickets. Some events may appear on many tickets. The tickets are thoroughly mixed in that box. We get an outcome of an experiment by picking a ticket from the box and see what's written on it.

Let's consider eagle sightings observation whose outcome is the number of eagles seen on a particular day. The event could 0 eagles seen, 1 eagle seen, or 7 eagles seen, etc. Using box-model, the box is the experiment and the number written on any tickets could be integers: 0, 1, 2, 3, .. etc. We then pick a ticket from the box, see the number written on the ticket that tells us the number of eagles seen for that particular day.

We're going to create the eagle sightings box using Clojure and fastmath library. We want to make a function `eagle-sightings` which simulates the act of picking a ticket from a box and that function returns the event or number written on a picked ticket.

For example:


::: {.sourceClojure}
```clojure
(eagle-sightings) => 1 ;; 1 eagle seen
```
:::



::: {.sourceClojure}
```clojure
(eagle-sightings) => 5 ;; 5 eagles seen
```
:::


Since the number returned from the `eagle-sightings` evaluation is completely unknown to use beforehand, we have to make or use some kind of number generator whose resulting number is unpredictable. That number generator is usually called a random number generator. Our programs run on computers which are deterministic so at best we can create or use _pseudo-random number generators_ (or PRNG for short). 

**A Detour to Pseudo-Random Number Generator (PRNG) in fastmath**

_Pseudo-random number generators_, if they are well coded, produce deterministic streams of output that appear to be random.

Let's play around with PRNGs.


::: {.sourceClojure}
```clojure
(require '[fastmath.random :as r])
```
:::


We create a prng with Mersenne-Twister algorithm


::: {.sourceClojure}
```clojure
(def prng0 (r/rng :mersenne))
```
:::


In the context of eagle sightings, we use `irandom` function to get a random integer from `prng0` and we limit the sightings at maximum 100 eagles seen.


::: {.sourceClojure}
```clojure
(r/irandom prng0 0 101)
```
:::



::: {.printedClojure}
```clojure
50

```
:::


let's take possible numbers from 10 sightings


::: {.sourceClojure}
```clojure
(repeatedly 10 (fn [] (r/irandom prng0 0 101)))
```
:::



::: {.printedClojure}
```clojure
(100 79 1 58 70 85 44 21 59 28)

```
:::


In the first sentence of this section, it is written that PRNG produce deterministic streams of output. It means that instances of a prng with the same algorithm and the same `seed`, produce identical stream of outputs.

Let's create 2 Mersenne-Twister PRNGs with the same `seed` 42.


::: {.sourceClojure}
```clojure
(def prng1 (r/rng :mersenne 42))
```
:::



::: {.sourceClojure}
```clojure
(def prng2 (r/rng :mersenne 42))
```
:::


Both yield identical stream of numbers.


::: {.sourceClojure}
```clojure
(repeatedly 10 (fn [] (r/irandom prng1 0 101)))
```
:::



::: {.printedClojure}
```clojure
(32 20 99 20 8 77 95 14 27 38)

```
:::



::: {.sourceClojure}
```clojure
(repeatedly 10 (fn [] (r/irandom prng2 0 101)))
```
:::



::: {.printedClojure}
```clojure
(32 20 99 20 8 77 95 14 27 38)

```
:::


Supplying seed when creating prng is an important part to make our _random_ experiment reproducible.

**Back to eagle sightings box model**

So, our `eagle-sightings` implementation could be like this


::: {.sourceClojure}
```clojure
(defn eagle-sightings
  "return number of eagles seen on a particular day.
  the number is an integer between from 0 to 100."
  []
  (let [rng (r/rng :mersenne)]
    (r/irandom rng 0 101)))
```
:::


Do 2 experiments


::: {.sourceClojure}
```clojure
(eagle-sightings)
```
:::



::: {.printedClojure}
```clojure
2

```
:::



::: {.sourceClojure}
```clojure
(eagle-sightings)
```
:::



::: {.printedClojure}
```clojure
50

```
:::


By using this box model implemented through codes and running in our computer, we mimic the experiment done in the real world. We can run this experiment many times and do further analysis to the model. There's still a problem that we haven't shown that this model behave like the real world experiment. We'll tackle that problem further in this intro.

Another advantage of using the model is we can create reproducible model. By using `seed` we can ensure the model produce reproducible results. Let's make a `generate-eagle-sightings-box` which given same `seed`, returns reproducible eagle sightings experiment. We can do analysis on the results of the model and we can give the function to another person who can do analysis on the identical results.


::: {.sourceClojure}
```clojure
(defn generate-eagle-sightings-box
  "given `seed` for prng, returns eagle sightings function.
  The eagle sightings function returns number of eagles seen on a particular day.
  the number is an integer between from 0 to 100."
  [seed]
  (let [rng (r/rng :mersenne seed)]
    (fn eagle-sightings [] (r/irandom rng 0 101))))
```
:::


generate experiment 1 using 1337 as seed


::: {.sourceClojure}
```clojure
(def eagle-sightings-1 (generate-eagle-sightings-box 1337))
```
:::


generate experiment 2 using 1337 as seed


::: {.sourceClojure}
```clojure
(def eagle-sightings-2 (generate-eagle-sightings-box 1337))
```
:::


run experiment 1 10 times


::: {.sourceClojure}
```clojure
(repeatedly 10 (fn [] (eagle-sightings-1)))
```
:::



::: {.printedClojure}
```clojure
(73 11 31 55 32 25 27 48 32 16)

```
:::


run experiment 2 10 times


::: {.sourceClojure}
```clojure
(repeatedly 10 (fn [] (eagle-sightings-2)))
```
:::



::: {.printedClojure}
```clojure
(73 11 31 55 32 25 27 48 32 16)

```
:::


both return identical results

**Daniel's**
1933 - Kolmogorov Axiom for probability theory

Omega Ω - sample space - the box - can be infinite

omega ω - an outcome - a ticket - the seed

random variable (r.v.) X - a function from Omega to numbers
so for every omega, X(omega) is a number

event A - a subset of Omega


::: {.sourceClojure}
```clojure
(defn Week [omega]
  (let [rng (r/rng :mersenne omega)]
    {:Tuesday-humidity (r/drandom rng 40 100)
     :Wednesday-humidity (r/drandom rng 40 100)
     :Thursday-humidity (r/drandom rng 40 100)
     :Friday-humidity (r/drandom rng 40 100)}))
```
:::



::: {.sourceClojure}
```clojure
(defn Tuesday-humidity [omega]
  (:Tuesday-humidity (Week omega)))
```
:::



::: {.sourceClojure}
```clojure
(defn Wednesday-humidity [omega]
  (:Wednesday-humidity (Week omega)))
```
:::



::: {.sourceClojure}
```clojure
(Tuesday-humidity 9)
```
:::



::: {.printedClojure}
```clojure
62.57346004344359

```
:::



::: {.sourceClojure}
```clojure
[(Tuesday-humidity 9)
 (Wednesday-humidity 9)]
```
:::



::: {.printedClojure}
```clojure
[62.57346004344359 44.10934240138366]

```
:::


Tuesday-humidity is a random variable.
A function omega -> number.


::: {.sourceClojure}
```clojure
(def Omega (range 100000))
```
:::


What are all the omegas for which
Tuesday-humidity is less that 60?


::: {.sourceClojure}
```clojure
(def Tuesday-humidity<60
  (->> Omega
       (filter (fn [omega]
                 (< (Tuesday-humidity omega) 60)))))
```
:::



::: {.sourceClojure}
```clojure
(count Omega)
```
:::



::: {.printedClojure}
```clojure
100000

```
:::



::: {.sourceClojure}
```clojure
(count Tuesday-humidity<60)
```
:::



::: {.printedClojure}
```clojure
33236

```
:::


Tuesday-humidity<60 is an event.


P(Tuesday-humidity<60) - the probability of an event


::: {.sourceClojure}
```clojure
(/ (float (count Tuesday-humidity<60))
   (count Omega))
```
:::



::: {.printedClojure}
```clojure
0.33236

```
:::


This is one way to define probabilities -
by counting.



X is a random variable.

What is the probability that X<60 ?



missing notions:
- measurability


```{=html}
<div style="background-color:grey;height:2px;width:100%;"></div>
```



```{=html}
<div></div>
```
